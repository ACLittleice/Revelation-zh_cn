/*
--------------------------------------------------------------------------------

	Revelation Shaders

	Copyright (C) 2024 HaringPro
	Apache License 2.0

    Pass: Spatial filter for indirect lighting

--------------------------------------------------------------------------------
*/

layout (local_size_x = 8, local_size_y = 8) in;
const vec2 workGroupsRender = vec2(0.5f, 0.5f);

//======// Utility //=============================================================================//

#include "/lib/Utility.glsl"

//======// Output //==============================================================================//

writeonly restrict uniform image2D colorimg3;

//======// Uniform //=============================================================================//

uniform sampler2D depthtex0;

uniform sampler2D colortex13; // Previous indirect light

uniform float viewWidth;

uniform mat4 gbufferProjectionInverse;

uniform vec2 viewPixelSize;
uniform vec2 viewSize;
uniform vec2 taaOffset;

//======// Function //============================================================================//

const uint padRadius = 1;

const uvec2 sharedSize = gl_WorkGroupSize.xy + padRadius * 2;
const uint sharedArea = sharedSize.x * sharedSize.y;
const uint localArea = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
const uint diffArea = sharedArea - localArea;
const vec2 rcpSharedSize = 1.0 / sharedSize;

shared vec3 sharedLight[sharedSize.x][sharedSize.y];
shared vec4 sharedData [sharedSize.x][sharedSize.y];

void CollectSharedData() {
    ivec2 sharedTexel = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy - padRadius);
    ivec2 shift = ivec2(viewWidth * 0.5, 0);

    // Unroll the loop manually
    {
        vec2 fi = (float(gl_LocalInvocationIndex) + 0.5) * rcpSharedSize;
        ivec2 index = ivec2(fract(fi.x) * sharedSize.x, fi.y);

        ivec2 sampleTexel = sharedTexel + index;

        sharedLight[index.x][index.y] = texelFetch(colortex13, sampleTexel, 0).rgb;
        sharedData [index.x][index.y] = texelFetch(colortex13, sampleTexel + shift, 0);
    }
    if (gl_LocalInvocationIndex < diffArea) {
        vec2 fi = (float(gl_LocalInvocationIndex + localArea) + 0.5) * rcpSharedSize;
        ivec2 index = ivec2(fract(fi.x) * sharedSize.x, fi.y);

        ivec2 sampleTexel = sharedTexel + index;

        sharedLight[index.x][index.y] = texelFetch(colortex13, sampleTexel, 0).rgb;
        sharedData [index.x][index.y] = texelFetch(colortex13, sampleTexel + shift, 0);
    }
}

vec3 ScreenToViewSpace(in vec3 screenPos) {
	vec3 NDCPos = screenPos * 2.0 - 1.0;
	#ifdef TAA_ENABLED
		NDCPos.xy -= taaOffset;
	#endif
	vec3 viewPos = projMAD(gbufferProjectionInverse, NDCPos);
	     viewPos /= gbufferProjectionInverse[2].w * NDCPos.z + gbufferProjectionInverse[3].w;

	return viewPos;
}

//======// Main //================================================================================//
void main() {
	ivec2 texel = ivec2(gl_GlobalInvocationID.xy);

    CollectSharedData();
    memoryBarrierShared();
    barrier();

    float depth = texelFetch(depthtex0, texel * 2, 0).x;
    if (depth < 1.0) {
        uvec2 sharedTexel = gl_LocalInvocationID.xy + padRadius;

        vec3 indirectData = sharedLight[sharedTexel.x][sharedTexel.y];
        vec4 normalDepthData = sharedData[sharedTexel.x][sharedTexel.y];

        vec3 viewPos = ScreenToViewSpace(vec3(vec2(gl_GlobalInvocationID.xy) * viewPixelSize * 2.0, depth));
        float NdotV = saturate(dot(normalDepthData.xyz, -normalize(viewPos)));

		const ivec2 offset[8] = {
			ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
			ivec2(-1,  0), 				 ivec2(1,  0),
			ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)
		};

        float sumWeight = 0.5;

        for (uint i = 0u; i < 8u; ++i) {
            uvec2 sampleSharedTexel = sharedTexel + offset[i];
            vec4 sampleData = sharedData[sampleSharedTexel.x][sampleSharedTexel.y];

            float weight = exp2(-0.1 * dotSelf(offset[i]));
            weight *= exp2(-abs(sampleData.w - normalDepthData.w) * 2.0 * NdotV); // Distance weight
            weight *= pow16(max0(dot(sampleData.xyz, normalDepthData.xyz))); // Normal weight

            vec3 sampleLight = sharedLight[sampleSharedTexel.x][sampleSharedTexel.y];

            indirectData += sampleLight * weight;
            sumWeight += weight;
        }

        indirectData /= sumWeight;

        imageStore(colorimg3, texel, vec4(indirectData, 1.0));
    }
}
