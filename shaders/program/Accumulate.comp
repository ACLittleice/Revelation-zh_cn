/*
--------------------------------------------------------------------------------

	Revelation Shaders

	Copyright (C) 2024 HaringPro
	Apache License 2.0

    Pass: Accumulation for indirect lighting and variance estimation
	Reference:  https://research.nvidia.com/sites/default/files/pubs/2017-07_Spatiotemporal-Variance-Guided-Filtering://svgf_preprint.pdf
                https://cescg.org/wp-content/uploads/2018/04/Dundr-Progressive-Spatiotemporal-Variance-Guided-Filtering-2.pdf

--------------------------------------------------------------------------------
*/

layout (local_size_x = 8, local_size_y = 8) in;
const vec2 workGroupsRender = vec2(1.0f, 0.5f);

//======// Utility //=============================================================================//

#include "/lib/Utility.glsl"

#define SSPT_MAX_BLENDED_FRAMES 160.0 // [20.0 24.0 28.0 32.0 36.0 40.0 48.0 56.0 64.0 72.0 80.0 96.0 112.0 128.0 144.0 160.0 192.0 224.0 256.0 320.0 384.0 448.0 512.0 640.0 768.0 896.0 1024.0]

#define SSPT_SAMPLER colortex3

//======// Output //==============================================================================//

layout (rgba16f, location = 0) restrict uniform image2D colorimg3;  // Current indirect light
layout (rgba16f, location = 1) restrict uniform image2D colorimg13; // Previous indirect light
layout (rg16,    location = 2) restrict uniform image2D colorimg14; // Previous moments

//======// Uniform //=============================================================================//

#include "/lib/utility/Uniform.glsl"

uniform sampler2D colortex13; // Previous indirect light
uniform sampler2D colortex14; // Previous moments

//======// Function //============================================================================//

#include "/lib/utility/Transform.glsl"
#include "/lib/utility/Fetch.glsl"
#include "/lib/utility/Noise.glsl"
#include "/lib/utility/Offset.glsl"

#if AO_ENABLED > 0
	#include "/lib/lighting/AmbientOcclusion.glsl"
#endif

float EstimateSpatialVariance(in ivec2 texel, in float luma) {
    // const float kernel[2][2] = {{0.25, 0.125}, {0.125, 0.0625}};
    const float kernel[3] = float[3](1.0, 2.0 / 3.0, 1.0 / 6.0);

    float sqLuma = luma * luma, sumWeight = 1.0;

    for (int x = -2; x <= 2; ++x) {
        for (int y = -2; y <= 2; ++y) {
            if (x == 0 && y == 0) continue;

            ivec2 sampleCoord = texel + ivec2(x, y) * 2;
            if (clamp(sampleCoord, ivec2(0), ivec2(viewSize * 0.5) - 1) == sampleCoord) {
                float weight = kernel[abs(x)] * kernel[abs(y)];
                float sampleLuma = GetLuminance(texelFetch(SSPT_SAMPLER, sampleCoord, 0).rgb);

                luma   += sampleLuma * weight;
                sqLuma += sampleLuma * sampleLuma * weight;

                sumWeight += weight;
            }
        }
    }

    luma   /= sumWeight;
    sqLuma /= sumWeight;
    return abs(sqLuma - luma * luma) * 0.1;
}

vec4 SpatialColor(in ivec2 texel) {
    vec3 indirectData = texelFetch(SSPT_SAMPLER, texel, 0).rgb;

    // const float kernel[2][2] = {{0.25, 0.125}, {0.125, 0.0625}};
    const float kernel[3] = float[3](1.0, 2.0 / 3.0, 1.0 / 6.0);

    float luma = GetLuminance(indirectData), sqLuma = luma * luma, sumWeight = 1.0;

    for (int x = -2; x <= 2; ++x) {
        for (int y = -2; y <= 2; ++y) {
            if (x == 0 && y == 0) continue;

            ivec2 sampleCoord = texel + ivec2(x, y) * 2;
            if (clamp(sampleCoord, ivec2(0), ivec2(viewSize * 0.5) - 1) == sampleCoord) {
                vec3 currentColor = texelFetch(SSPT_SAMPLER, sampleCoord, 0).rgb;

                float weight = kernel[abs(x)] * kernel[abs(y)];
                float sampleLuma = GetLuminance(currentColor);

                indirectData += currentColor * weight;
                luma   += sampleLuma * weight;
                sqLuma += sampleLuma * sampleLuma * weight;

                sumWeight += weight;
            }
        }
    }
    luma   /= sumWeight;
    sqLuma /= sumWeight;

    return vec4(indirectData / sumWeight, abs(sqLuma - luma * luma) * 0.1);
}

//======// Main //================================================================================//
void main() {
	ivec2 screenTexel = ivec2(gl_GlobalInvocationID.xy);
    vec2 screenCoord = vec2(gl_GlobalInvocationID.xy) * viewPixelSize;

	if (screenCoord.x < 0.5) {
        ivec2 currentTexel = screenTexel * 2;
        float depth = sampleDepth(currentTexel);

        if (depth < 1.0) {
            vec3 worldNormal = FetchWorldNormal(sampleGbufferData0(currentTexel));
            vec4 indirectCurrent = vec4(vec3(0.0), 1.0);
            vec4 indirectHistory = indirectCurrent;

            vec3 screenPos = vec3(screenCoord * 2.0, depth);
            vec3 viewPos = ScreenToViewSpace(screenPos);

            // #if AO_ENABLED == 1
            //     float dither = BlueNoiseTemporal(currentTexel);
            //     if (depth > 0.56) indirectCurrent.a = CalculateSSAO(screenPos.xy, viewPos, mat3(gbufferModelView) * worldNormal, dither);
            // #endif

            vec2 prevCoord = Reproject(screenPos).xy;
            if (saturate(prevCoord) != prevCoord || worldTimeChanged || depth < 0.56) {
                indirectCurrent = SpatialColor(screenTexel);
                indirectHistory.rgb = indirectCurrent.rgb;
            } else {
                prevCoord *= 0.5;
                vec4 prevLight = vec4(0.0);
                float sumWeight = 0.0;
                float cameraMovement = distance(cameraPosition, previousCameraPosition);

                vec2 prevMoments = vec2(0.0);
                float isPrevValid = 0.0;
                for (uint i = 0u; i < 4u; ++i) {
                    vec2 sampleCoord = prevCoord + (offset2x2[i] - 0.5) * viewPixelSize;
                    if (clamp(sampleCoord, vec2(0.0), 0.5 - viewPixelSize) == sampleCoord) {
                        vec4 prevData = texture(colortex13, sampleCoord + vec2(0.5, 0.0), 0);

                        vec4 sampleLight = texture(colortex13, sampleCoord);

                        float weight = step(abs(floor(sampleCoord.x)) + abs(floor(sampleCoord.y)), 0.5);
                        weight *= step((distance(viewPos.z, prevData.w) - cameraMovement) / abs(viewPos.z), 0.1);
                        // weight *= pow4(max0(dot(prevData.xyz, worldNormal)));
                        isPrevValid = max(isPrevValid, weight);
                        weight *= sampleLight.w;

                        prevMoments += texture(colortex14, sampleCoord).xy * weight;
                        prevLight += sampleLight * weight;
                        sumWeight += weight;
                    }
                }

                indirectCurrent.rgb = texelFetch(SSPT_SAMPLER, screenTexel, 0).rgb;

                if (sumWeight > 1e-5) {
                    prevLight /= sumWeight;
                    prevMoments /= sumWeight;

                    indirectHistory.a = min(++prevLight.a * isPrevValid, SSPT_MAX_BLENDED_FRAMES);
                    float alpha = indirectHistory.a * rcp(indirectHistory.a + 1.0);

                    indirectCurrent.rgb = indirectHistory.rgb = mix(indirectCurrent.rgb, prevLight.rgb, alpha);

                    float luminance = GetLuminance(indirectHistory.rgb);

                    vec2 currMoments = vec2(luminance, luminance * luminance);
                    vec2 historyMoments = mix(currMoments, prevMoments, alpha);

                    imageStore(colorimg14, screenTexel, vec4(historyMoments, vec2(1.0)));
                    if (indirectHistory.a < 4.0) {
                        indirectCurrent.a = EstimateSpatialVariance(screenTexel, luminance);
                    } else {
                        indirectCurrent.a = abs(historyMoments.y - historyMoments.x * historyMoments.x) * 0.1;
                    }
                } else {
                    indirectCurrent = SpatialColor(screenTexel);
                    indirectHistory.rgb = indirectCurrent.rgb;
                }
            }

            imageStore(colorimg3, screenTexel, clamp16f(indirectCurrent));
            imageStore(colorimg13, screenTexel, clamp16f(indirectHistory));
        }
    } else {
        ivec2 currentTexel = ivec2(gl_GlobalInvocationID.xy) * 2 - ivec2(viewWidth, 0);
        float depth = sampleDepth(currentTexel);
        if (depth < 1.0) {
            // depth += 0.38 * step(depth, 0.56);

            vec3 worldNormal = FetchWorldNormal(sampleGbufferData0(currentTexel));
            float viewDepth = ScreenToViewDepth(depth);

            imageStore(colorimg13, screenTexel, vec4(worldNormal, viewDepth));
        }
    }
}